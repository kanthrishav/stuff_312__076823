import os
import time
import math
import numpy as np
import pandas as pd
import vaex
import panel as pn
from bokeh.plotting import figure
from bokeh.models import ColumnDataSource, HoverTool, Span
from numba import njit, prange

# ---------------------------
# INITIALIZE PANEL (avoid extension warnings)
# ---------------------------
pn.extension()  # Do not explicitly specify "bokeh"
pn.config.raw_css.append("""
    .bk-root { font-family: "Courier New", monospace; }
    body { margin: 0; padding: 0; }
""")
print(f"[{time.time():.3f}] Panel extension loaded.")

# ---------------------------
# PARAMETERS & FILE PATHS
# ---------------------------
LOS_thresh = 0.035  # Updated threshold
original_file_path = "data_original.feather"
preprocessed_file_path = "data_preprocessed.feather"

# ---------------------------
# DATA PREPROCESSING (with timing prints)
# ---------------------------
start_total = time.time()
preprocess_start = time.time()

if os.path.exists(preprocessed_file_path):
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed file found. Loading preprocessed dataframe.")
    pdf = pd.read_feather(preprocessed_file_path)
else:
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed file not found. Reading original data and starting preprocessing.")
    pdf = pd.read_feather(original_file_path)
    
    # --- Compute basic geometric quantities (vectorized) ---
    pdf['az'] = np.arctan2(pdf['y'].values, pdf['x'].values)  # in radians
    pdf['r'] = np.hypot(pdf['x'].values, pdf['y'].values)       # distance
    pdf['Motion'] = np.where(pdf['dp'].isin([1,2,5,6]), 1, 0)
    print(f"[{time.time()-preprocess_start:.3f} sec] Basic columns computed.")

    # --- LOS Computation (parallelized with Numba) ---
    @njit(parallel=True)
    def compute_all_los(sorted_az, sorted_r, group_start, group_end, thresh):
        n_groups = group_start.shape[0]
        los_sorted = np.empty(sorted_az.shape[0], dtype=np.int8)
        for i in prange(n_groups):
            start = group_start[i]
            end = group_end[i]
            for j in range(start, end):
                flag = 1
                for k in range(start, end):
                    if j != k:
                        if sorted_r[k] < sorted_r[j] and math.fabs(sorted_az[k] - sorted_az[j]) < thresh:
                            flag = 0
                            break
                los_sorted[j] = flag
        return los_sorted

    mc_arr = pdf['mc'].values
    order = np.argsort(mc_arr)
    sorted_mc = mc_arr[order]
    sorted_az = pdf['az'].values[order]
    sorted_r = pdf['r'].values[order]
    unique_mc, group_start = np.unique(sorted_mc, return_index=True)
    group_end = np.empty_like(group_start)
    for i in range(len(group_start)-1):
        group_end[i] = group_start[i+1]
    group_end[-1] = len(sorted_mc)
    
    los_sorted = compute_all_los(sorted_az, sorted_r, group_start, group_end, LOS_thresh)
    los = np.empty_like(los_sorted)
    los[order] = los_sorted
    pdf['LOS'] = los
    print(f"[{time.time()-preprocess_start:.3f} sec] LOS column computed.")

    # --- Label Computation (vectorized) ---
    mirrProb = pdf['mirrProb'].values
    egoYawRate = pdf['egoYawRate'].values
    egoSpeed = pdf['egoSpeed'].values
    Motion = pdf['Motion'].values
    LOS = pdf['LOS'].values
    y_vals = pdf['y'].values
    cond = (mirrProb < 71) & (egoYawRate < 2) & (egoSpeed > 0.2) & (Motion == 1) & (LOS == 1)
    labels = np.zeros(len(pdf), dtype=np.int8)
    labels[np.where(cond & (y_vals >= -2) & (y_vals <= 2))] = 1
    labels[np.where(cond & (y_vals >= -6) & (y_vals < -2))] = 2
    labels[np.where(cond & (y_vals > 2) & (y_vals <= 6))] = 3
    pdf['label'] = labels
    print(f"[{time.time()-preprocess_start:.3f} sec] Label column computed.")

    # --- OOI Computation (vectorized using NumPy) ---
    labels_arr = pdf['label'].values
    mc_arr = pdf['mc'].values
    r_arr = pdf['r'].values
    mask = (labels_arr == 1) | (labels_arr == 2) | (labels_arr == 3)
    sel = np.where(mask)[0]
    pdf['OOI'] = 0
    if sel.size > 0:
        sel_mc = mc_arr[sel]
        sel_label = labels_arr[sel]
        sel_r = r_arr[sel]
        order_sel = np.argsort(sel_r)
        ordered_sel = sel[order_sel]
        keys = np.stack((mc_arr[ordered_sel], labels_arr[ordered_sel]), axis=1)
        unique_keys, unique_idx = np.unique(keys, axis=0, return_index=True)
        selected_indices = ordered_sel[unique_idx]
        pdf.loc[selected_indices, 'OOI'] = 1
    print(f"[{time.time()-preprocess_start:.3f} sec] OOI column computed.")

    pdf.to_feather(preprocessed_file_path)
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed dataframe saved.")

print(f"[{time.time()-preprocess_start:.3f} sec] Data preprocessing complete.")
print(f"[{time.time()-start_total:.3f} sec] Total initialization complete.")

# Use Vaex for on-demand filtering
df = vaex.from_pandas(pdf)

# ---------------------------
# DASHBOARD CREATION
# ---------------------------
dashboard_start = time.time()

# --- Radar Cycle Slider using unique values from dataframe ---
unique_mcs = np.sort(pdf['mc'].unique())
radar_cycle_slider = pn.widgets.DiscreteSlider(
    name='Radar Cycle Slider',
    options=list(unique_mcs),
    value=unique_mcs[0],
    width=1800
)

# --- Filter Panel (placed in Graph Section - Subsection 1) ---
eyr_slider = pn.widgets.FloatSlider(name='EYR Slider', start=0, end=5, value=2, step=0.01)
es_slider = pn.widgets.FloatSlider(name='ES Slider', start=0, end=10, value=0.2, step=0.1)
mp_slider = pn.widgets.FloatSlider(name='MP Slider', start=0, end=100, value=71, step=1)
age_slider = pn.widgets.FloatSlider(name='Age Slider', start=0, end=100, value=20, step=1)
# Now place X-axis and Y-axis sliders here (vertically below Age Slider)
x_axis_slider = pn.widgets.FloatSlider(name='X-axis Slider', start=1, end=30, value=10, step=1)
y_axis_slider = pn.widgets.FloatSlider(name='Y-axis Slider', start=-50, end=200, value=100, step=1)
filter_panel = pn.Column(eyr_slider, es_slider, mp_slider, age_slider, x_axis_slider, y_axis_slider, sizing_mode="stretch_width")

# --- Save Button ---
save_button = pn.widgets.Button(name='Save Current State', button_type='primary')

# ---------------------------
# Prepare ColumnDataSources
# ---------------------------
object_scatter_source = ColumnDataSource(data=dict(x=[], y=[], color=[], size=[], hover=[]))
# For patches we use a patches glyph â€“ each entry is a list of x coordinates and y coordinates.
object_patch_source = ColumnDataSource(data=dict(xs=[], ys=[], color=[]))
ego_source = ColumnDataSource(data=dict(x=[0], y=[0], hover=[""]))

ts_source_ego = ColumnDataSource(data=dict(mc=[], poe=[]))
ts_source_left = ColumnDataSource(data=dict(mc=[], poe=[]))
ts_source_right = ColumnDataSource(data=dict(mc=[], poe=[]))

# ---------------------------
# Create Bokeh Figures
# ---------------------------
# OBJECT PLOT: Height set to 1000; y_range starts at -2.
object_plot = figure(
    title="Object Plot", 
    sizing_mode="stretch_both", 
    tools="pan,wheel_zoom,reset",
    height=1000
)
# Initially set x_range and y_range based on slider values.
object_plot.x_range.start = -x_axis_slider.value
object_plot.x_range.end = x_axis_slider.value
object_plot.y_range.start = -2
object_plot.y_range.end = y_axis_slider.value

# Vertical dotted lines at x = -6, -2, 2, 6 (x-axis shows global y)
for xv in [-6, -2, 2, 6]:
    span = Span(location=xv, dimension='height', line_color='purple', line_dash='dotted', line_width=1)
    object_plot.add_layout(span)

# Bold border lines on right and top edges.
right_border = Span(location=object_plot.x_range.end, dimension='height', line_color="black", line_width=3)
top_border = Span(location=object_plot.y_range.end, dimension='width', line_color="black", line_width=3)
object_plot.add_layout(right_border)
object_plot.add_layout(top_border)

# Draw object scatter points.
scatter_renderer = object_plot.scatter(
    'x', 'y', source=object_scatter_source,
    size='size', color='color', fill_alpha=0.6
)

# Draw rectangular bounds using patches.
patch_renderer = object_plot.patches(
    'xs', 'ys', source=object_patch_source,
    fill_alpha=0.5, line_color='color', line_width=10
)

# Draw ego point at origin.
ego_renderer = object_plot.scatter(
    'x', 'y', source=ego_source, size=4, color='black', fill_alpha=1.0
)

# Hover tools.
object_hover = HoverTool(tooltips=[("Details", "@hover")], renderers=[scatter_renderer])
object_plot.add_tools(object_hover)
ego_hover = HoverTool(tooltips=[("Ego", "@hover")], renderers=[ego_renderer])
object_plot.add_tools(ego_hover)

# TIME-SERIES PLOTS
ts_plot_ego = figure(
    title="inEgoLaneOOI", 
    sizing_mode="stretch_both", 
    tools="pan,wheel_zoom,reset", 
    y_range=(0, 100)
)
ts_plot_ego.line('mc', 'poe', source=ts_source_ego, line_width=1, color='blue')
ts_plot_ego.circle('mc', 'poe', source=ts_source_ego, size=3, color='blue')

ts_plot_left = figure(
    title="inLeftEgoLaneOOI", 
    sizing_mode="stretch_both", 
    tools="pan,wheel_zoom,reset", 
    y_range=(0, 100)
)
ts_plot_left.line('mc', 'poe', source=ts_source_left, line_width=1, color='green')
ts_plot_left.circle('mc', 'poe', source=ts_source_left, size=3, color='green')

ts_plot_right = figure(
    title="inRightEgoLaneOOI", 
    sizing_mode="stretch_both", 
    tools="pan,wheel_zoom,reset", 
    y_range=(0, 100)
)
ts_plot_right.line('mc', 'poe', source=ts_source_right, line_width=1, color='magenta')
ts_plot_right.circle('mc', 'poe', source=ts_source_right, size=3, color='magenta')

empty_plot = figure(sizing_mode="stretch_both", toolbar_location=None)

# ---------------------------
# Callback Functions
# ---------------------------
def update_object_plot():
    """Update object plot (scatter, patches, ego point) using real data."""
    current_mc = radar_cycle_slider.value
    # Update axis limits based on X-axis and Y-axis sliders.
    x_lim = x_axis_slider.value
    y_lim = y_axis_slider.value
    object_plot.x_range.start = -x_lim
    object_plot.x_range.end = x_lim
    object_plot.y_range.start = -2
    object_plot.y_range.end = y_lim
    # Update right and top border spans.
    right_border.location = object_plot.x_range.end
    top_border.location = object_plot.y_range.end

    # Filter data for the current radar cycle.
    df_cycle = df[df.mc == current_mc].to_pandas_df()
    # Apply additional filter sliders.
    df_cycle = df_cycle[
        (df_cycle.egoYawRate < eyr_slider.value) &
        (df_cycle.egoSpeed > es_slider.value) &
        (df_cycle.mirrProb < mp_slider.value) &
        (df_cycle.lc > age_slider.value)
    ]
    
    # (Since all mc values have objects, df_cycle should not be empty.)
    if df_cycle.empty:
        object_scatter_source.data = dict(x=[], y=[], color=[], size=[], hover=[])
        object_patch_source.data = dict(xs=[], ys=[], color=[])
        ego_source.data = dict(x=[0], y=[0], hover=[""])
        return

    scatter_x, scatter_y, colors, sizes, hovers = [], [], [], [], []
    patch_xs, patch_ys, patch_colors = [], [], []

    for _, row in df_cycle.iterrows():
        # Determine color and size.
        if row['OOI'] == 1:
            col = 'red'
            size_val = 4
        elif row['LOS'] == 1 and row['label'] == 1:
            col = 'blue'
            size_val = 3
        elif row['LOS'] == 1 and row['label'] == 2:
            col = 'green'
            size_val = 3
        elif row['LOS'] == 1 and row['label'] == 3:
            col = 'magenta'
            size_val = 3
        else:
            col = 'grey'
            size_val = 2

        # For scatter: Plot x = object's global y, y = object's global x.
        scatter_x.append(row['y'])
        scatter_y.append(row['x'])
        colors.append(col)
        sizes.append(size_val)
        # Format hover text: id, mirrProb, dp, poe as int; vx, vy (2 decimals); pfd (4 decimals).
        if row['Motion'] == 1:
            hover_text = (f"id: {int(row['id'])}, mirrProb: {int(row['mirrProb'])}, "
                          f"dp: {int(row['dp'])}, poe: {int(row['poe'])}, "
                          f"vx: {row['vx']:.2f}, vy: {row['vy']:.2f}, pfd: {row['pfd']:.4f}")
        else:
            hover_text = ""
        hovers.append(hover_text)
        
        # --- Compute rectangular bounds using explicit corners ---
        lf = row['lf'] * 0.001
        lr = row['lr'] * 0.001
        wl = row['wl'] * 0.001
        wr = row['wr'] * 0.001
        # Local corners: front-left, front-right, rear-right, rear-left.
        local_corners = np.array([[lf, wl],
                                   [lf, -wr],
                                   [-lr, -wr],
                                   [-lr, wl]])
        # Rotation matrix.
        theta = row['orient']
        R = np.array([[math.cos(theta), -math.sin(theta)],
                      [math.sin(theta),  math.cos(theta)]])
        # Global corners.
        global_corners = (R @ local_corners.T).T + np.array([row['x'], row['y']])
        # For plotting, swap coordinates: plot_x = global_corners[:,1], plot_y = global_corners[:,0].
        poly_x = global_corners[:, 1].tolist()
        poly_y = global_corners[:, 0].tolist()
        # Close the polygon.
        poly_x.append(poly_x[0])
        poly_y.append(poly_y[0])
        patch_xs.append(poly_x)
        patch_ys.append(poly_y)
        patch_colors.append(col)
    
    object_scatter_source.data = dict(x=scatter_x, y=scatter_y, color=colors, size=sizes, hover=hovers)
    object_patch_source.data = dict(xs=patch_xs, ys=patch_ys, color=patch_colors)
    
    # Update ego point.
    ego_info = df_cycle.iloc[0]
    ego_hover_text = (f"mc: {int(ego_info['mc'])}, "
                      f"egoSpeed: {ego_info['egoSpeed']:.3f}, "
                      f"egoYawRate: {math.degrees(ego_info['egoYawRate']):.3f} deg/s")
    ego_source.data = dict(x=[0], y=[0], hover=[ego_hover_text])

def update_time_series(source, label_val, title_prefix):
    """Update POE vs. mc plot for an object with given label & OOI==1."""
    current_mc = radar_cycle_slider.value
    df_cycle = df[df.mc == current_mc].to_pandas_df()
    obj_data = df_cycle[(df_cycle.OOI == 1) & (df_cycle.label == label_val)]
    if not obj_data.empty:
        obj_id = obj_data.iloc[0]['id']
        current_poe = obj_data.iloc[0]['poe']
        df_obj = df[df.id == obj_id].to_pandas_df()
        df_obj = df_obj[(df_obj.mc >= current_mc - 5) & (df_obj.mc <= current_mc + 5)]
        df_obj = df_obj.sort_values('mc')
        source.data = dict(mc=df_obj['mc'].tolist(), poe=df_obj['poe'].tolist())
        return f"<b>{title_prefix} OOId: {obj_id} | POE: {current_poe}</b>"
    else:
        source.data = dict(mc=[], poe=[])
        return f"<b>{title_prefix} No Data</b>"

def update_all(event=None):
    update_object_plot()
    title_ego = update_time_series(ts_source_ego, 1, "inEgoLaneOOI")
    title_left = update_time_series(ts_source_left, 2, "inLeftEgoLaneOOI")
    title_right = update_time_series(ts_source_right, 3, "inRightEgoLaneOOI")
    ts_plot_ego.title.text = title_ego
    ts_plot_left.title.text = title_left
    ts_plot_right.title.text = title_right

for widget in [radar_cycle_slider, x_axis_slider, y_axis_slider, eyr_slider, es_slider, mp_slider, age_slider]:
    widget.param.watch(update_all, 'value')

def save_callback(event):
    pn.panel(dashboard_layout).save('dashboard_state.html', resources='inline')
    print(f"[{time.time()-dashboard_start:.3f} sec] Dashboard state saved.")
save_button.on_click(save_callback)

# ---------------------------
# LAYOUT CONSTRUCTION
# ---------------------------
header_section = pn.pane.Markdown(
    "<h1 style='font-family: Courier New, monospace; text-align: center;'>Objects Of Interest (OOI)</h1>",
    sizing_mode="stretch_width", height=50
)

# Top slider section now contains only the Radar Cycle Slider.
slider_section = pn.Row(radar_cycle_slider, sizing_mode="stretch_width", height=50)

# Create a GridSpec (max_height=1000) with 2 rows and 3 columns.
# Layout:
#  â€¢ Column 0: Filter Panel (row 0) and ts_plot_left (row 1)
#  â€¢ Column 1: Object Plot spanning both rows (covering subsections 2 and 5)
#  â€¢ Column 2: ts_plot_ego (row 0) and ts_plot_right (row 1)
grid = pn.GridSpec(sizing_mode='stretch_both', max_height=1000)
grid[0, 0] = filter_panel
grid[1, 0] = ts_plot_left
grid[0:2, 1] = object_plot
grid[0, 2] = ts_plot_ego
grid[1, 2] = ts_plot_right

dashboard_layout = pn.Column(header_section, slider_section, grid, save_button,
                               sizing_mode="stretch_both", margin=0)

# Ensure initial update with real data.
update_all()

dashboard_layout.servable()
print(f"[{time.time()-dashboard_start:.3f} sec] Dashboard creation complete.")

# ---------------------------
# LAUNCH THE DASHBOARD
# ---------------------------
pn.serve(dashboard_layout, show=True, start=True)
