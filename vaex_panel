import os
import time
import math
import numpy as np
import pandas as pd
import vaex
import panel as pn
from bokeh.plotting import figure
from bokeh.models import ColumnDataSource, HoverTool, Span
from numba import njit, prange

# ---------------------------
# INITIALIZE PANEL (fix extension warning)
# ---------------------------
pn.extension()  # Do not specify "bokeh" explicitly
pn.config.raw_css.append("""
    .bk-root { font-family: "Courier New", monospace; }
    body { margin: 0; padding: 0; }
""")
print(f"[{time.time():.3f}] Panel extension loaded.")

# ---------------------------
# PARAMETERS & FILE PATHS
# ---------------------------
LOS_thresh = 0.035  # Updated threshold (radians)
original_file_path = "data_original.feather"
preprocessed_file_path = "data_preprocessed.feather"

# ---------------------------
# DATA PREPROCESSING (with timing prints)
# ---------------------------
start_total = time.time()
preprocess_start = time.time()

if os.path.exists(preprocessed_file_path):
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed file found. Loading preprocessed dataframe.")
    pdf = pd.read_feather(preprocessed_file_path)
else:
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed file not found. Reading original data and starting preprocessing.")
    pdf = pd.read_feather(original_file_path)
    
    # --- Compute basic geometric quantities (vectorized) ---
    pdf['az'] = np.arctan2(pdf['y'].values, pdf['x'].values)  # azimuth angle (radians)
    pdf['r'] = np.hypot(pdf['x'].values, pdf['y'].values)       # range (distance)
    pdf['Motion'] = np.where(pdf['dp'].isin([1, 2, 5, 6]), 1, 0)
    print(f"[{time.time()-preprocess_start:.3f} sec] Basic columns (az, r, Motion) computed.")

    # --- LOS Computation (fully parallelized with Numba) ---
    @njit(parallel=True)
    def compute_all_los(sorted_az, sorted_r, group_start, group_end, thresh):
        n_groups = group_start.shape[0]
        los_sorted = np.empty(sorted_az.shape[0], dtype=np.int8)
        for i in prange(n_groups):
            start = group_start[i]
            end = group_end[i]
            for j in range(start, end):
                flag = 1
                for k in range(start, end):
                    if j != k:
                        if sorted_r[k] < sorted_r[j] and math.fabs(sorted_az[k] - sorted_az[j]) < thresh:
                            flag = 0
                            break
                los_sorted[j] = flag
        return los_sorted

    # Sort indices by radar cycle for efficient group processing
    mc_arr = pdf['mc'].values
    order = np.argsort(mc_arr)
    sorted_mc = mc_arr[order]
    sorted_az = pdf['az'].values[order]
    sorted_r = pdf['r'].values[order]
    unique_mc, group_start = np.unique(sorted_mc, return_index=True)
    group_end = np.empty_like(group_start)
    for i in range(len(group_start)-1):
        group_end[i] = group_start[i+1]
    group_end[-1] = len(sorted_mc)
    
    # Compute LOS for all objects in sorted order, then reassemble
    los_sorted = compute_all_los(sorted_az, sorted_r, group_start, group_end, LOS_thresh)
    los = np.empty_like(los_sorted)
    los[order] = los_sorted
    pdf['LOS'] = los
    print(f"[{time.time()-preprocess_start:.3f} sec] LOS column computed.")

    # --- Label Computation (vectorized) ---
    mirrProb = pdf['mirrProb'].values
    egoYawRate = pdf['egoYawRate'].values
    egoSpeed = pdf['egoSpeed'].values
    Motion = pdf['Motion'].values
    LOS = pdf['LOS'].values
    y_vals = pdf['y'].values
    cond = (mirrProb < 71) & (egoYawRate < 2) & (egoSpeed > 0.2) & (Motion == 1) & (LOS == 1)
    labels = np.zeros(len(pdf), dtype=np.int8)
    labels[np.where(cond & (y_vals >= -2) & (y_vals <= 2))] = 1
    labels[np.where(cond & (y_vals >= -6) & (y_vals < -2))] = 2
    labels[np.where(cond & (y_vals > 2) & (y_vals <= 6))] = 3
    pdf['label'] = labels
    print(f"[{time.time()-preprocess_start:.3f} sec] Label column computed.")

    # --- OOI Computation (fully vectorized using NumPy) ---
    labels_arr = pdf['label'].values
    mc_arr = pdf['mc'].values
    r_arr = pdf['r'].values
    mask = (labels_arr == 1) | (labels_arr == 2) | (labels_arr == 3)
    sel = np.where(mask)[0]
    pdf['OOI'] = 0  # initialize all to 0
    if sel.size > 0:
        # For each unique (mc, label) pair, choose the object with minimum range.
        sel_mc = mc_arr[sel]
        sel_label = labels_arr[sel]
        sel_r = r_arr[sel]
        order_sel = np.argsort(sel_r)
        ordered_sel = sel[order_sel]
        keys = np.stack((mc_arr[ordered_sel], labels_arr[ordered_sel]), axis=1)
        unique_keys, unique_idx = np.unique(keys, axis=0, return_index=True)
        selected_indices = ordered_sel[unique_idx]
        pdf.loc[selected_indices, 'OOI'] = 1
    print(f"[{time.time()-preprocess_start:.3f} sec] OOI column computed.")

    # --- Save the preprocessed dataframe ---
    pdf.to_feather(preprocessed_file_path)
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed dataframe saved to {preprocessed_file_path}.")

print(f"[{time.time()-preprocess_start:.3f} sec] Data preprocessing complete.")
print(f"[{time.time()-start_total:.3f} sec] Total initialization complete.")

# Convert to Vaex dataframe (for on-demand filtering)
df = vaex.from_pandas(pdf)

# ---------------------------
# DASHBOARD CREATION
# ---------------------------
dashboard_start = time.time()

# --- Main slider widgets (placed in a horizontal row) ---
# Elongate Radar Cycle Slider by 200%
y_axis_slider = pn.widgets.FloatSlider(name='Y-axis Slider', start=-200, end=200, value=100, step=1)
x_axis_slider = pn.widgets.FloatSlider(name='X-axis Slider', start=1, end=30, value=10, step=1)
radar_cycle_slider = pn.widgets.IntSlider(name='Radar Cycle Slider', 
                                           start=int(df.mc.min()), end=int(df.mc.max()),
                                           value=int(df.mc.min()), step=1, width=1200)

# --- Filter sliders (stacked vertically in Graph Subsection 1) ---
eyr_slider = pn.widgets.FloatSlider(name='EYR Slider', start=0, end=5, value=2, step=0.01)
es_slider = pn.widgets.FloatSlider(name='ES Slider', start=0, end=10, value=0.2, step=0.1)
mp_slider = pn.widgets.FloatSlider(name='MP Slider', start=0, end=100, value=71, step=1)
age_slider = pn.widgets.FloatSlider(name='Age Slider', start=0, end=100, value=20, step=1)

# --- Save button to export dashboard state as interactive HTML ---
save_button = pn.widgets.Button(name='Save Current State', button_type='primary')

# ---------------------------
# Prepare ColumnDataSources for fast updates
# ---------------------------
object_scatter_source = ColumnDataSource(data=dict(x=[], y=[], color=[], size=[], hover=[]))
object_patch_source = ColumnDataSource(data=dict(xs=[], ys=[], color=[]))
ego_source = ColumnDataSource(data=dict(x=[0], y=[0], hover=[""]))

ts_source_ego = ColumnDataSource(data=dict(mc=[], poe=[]))
ts_source_left = ColumnDataSource(data=dict(mc=[], poe=[]))
ts_source_right = ColumnDataSource(data=dict(mc=[], poe=[]))

# ---------------------------
# Create Bokeh Figures
# ---------------------------
# Object Plot: Increase height to 1000 and set y_range.start to -2
object_plot = figure(title="Object Plot", sizing_mode="stretch_both", tools="pan,wheel_zoom,reset", height=1000)
object_plot.x_range.start = -x_axis_slider.value
object_plot.x_range.end = x_axis_slider.value
object_plot.y_range.start = -2
object_plot.y_range.end = y_axis_slider.value

# Draw vertical dotted lines at x = -6, -2, 2, 6 (x-axis represents object y-distance)
for xv in [-6, -2, 2, 6]:
    span = Span(location=xv, dimension='height', line_color='purple', line_dash='dotted', line_width=1)
    object_plot.add_layout(span)

# Draw scatter points for objects
scatter_renderer = object_plot.scatter('x', 'y', source=object_scatter_source,
                                         size='size', color='color', fill_alpha=0.6)
# Draw rectangular bounds using patches.
# Note: Each patchâ€™s coordinates are explicitly closed by appending the first point.
object_plot.patches('xs', 'ys', source=object_patch_source, fill_alpha=0.4, line_color='color', line_width=10)
# Draw ego point at origin; scatter size increased to 4.
ego_renderer = object_plot.scatter('x', 'y', source=ego_source, size=4, color='black', fill_alpha=1.0)

# Hover tool for object scatter
object_hover = HoverTool(tooltips=[("Details", "@hover")], renderers=[scatter_renderer])
object_plot.add_tools(object_hover)
# Separate hover tool for the ego point.
ego_hover = HoverTool(tooltips=[("Ego", "@hover")], renderers=[ego_renderer])
object_plot.add_tools(ego_hover)

# Time-series plots for POE vs. mc
ts_plot_ego = figure(title="inEgoLaneOOI", sizing_mode="stretch_both", tools="pan,wheel_zoom,reset", y_range=(0, 100))
ts_plot_ego.line('mc', 'poe', source=ts_source_ego, line_width=1, color='blue')
ts_plot_ego.circle('mc', 'poe', source=ts_source_ego, size=3, color='blue')

ts_plot_left = figure(title="inLeftEgoLaneOOI", sizing_mode="stretch_both", tools="pan,wheel_zoom,reset", y_range=(0, 100))
ts_plot_left.line('mc', 'poe', source=ts_source_left, line_width=1, color='green')
ts_plot_left.circle('mc', 'poe', source=ts_source_left, size=3, color='green')

ts_plot_right = figure(title="inRightEgoLaneOOI", sizing_mode="stretch_both", tools="pan,wheel_zoom,reset", y_range=(0, 100))
ts_plot_right.line('mc', 'poe', source=ts_source_right, line_width=1, color='magenta')
ts_plot_right.circle('mc', 'poe', source=ts_source_right, size=3, color='magenta')

empty_plot = figure(sizing_mode="stretch_both", toolbar_location=None)

# ---------------------------
# Callback Functions for Fast Updates
# ---------------------------
def update_object_plot():
    """Update the main object plot (scatter and patches) instantly using ColumnDataSource."""
    current_mc = radar_cycle_slider.value
    # Use X-axis and Y-axis slider values:
    x_lim = x_axis_slider.value  # x-axis: from -x_lim to +x_lim
    y_lim = y_axis_slider.value  # y-axis: from -2 to y_lim (y_min now -2)
    object_plot.x_range.start = -x_lim
    object_plot.x_range.end = x_lim
    object_plot.y_range.start = -2
    object_plot.y_range.end = y_lim

    # Filter data for the current radar cycle and apply filter sliders
    df_cycle = df[df.mc == current_mc].to_pandas_df()
    df_cycle = df_cycle[(df_cycle.egoYawRate < eyr_slider.value) &
                        (df_cycle.egoSpeed > es_slider.value) &
                        (df_cycle.mirrProb < mp_slider.value) &
                        (df_cycle.lc > age_slider.value)]
    
    # If no objects are available after filtering, clear the data sources.
    if df_cycle.empty:
        object_scatter_source.data = dict(x=[], y=[], color=[], size=[], hover=[])
        object_patch_source.data = dict(xs=[], ys=[], color=[])
        ego_source.data = dict(x=[0], y=[0], hover=[""])
        return

    scatter_x, scatter_y, colors, sizes, hovers = [], [], [], [], []
    patch_xs, patch_ys, patch_colors = [], [], []

    for _, row in df_cycle.iterrows():
        # Determine color and size based on OOI, LOS and label.
        if row['OOI'] == 1:
            color = 'red'
            size = 4
        elif row['LOS'] == 1 and row['label'] == 1:
            color = 'blue'  # Changed from lightblue
            size = 3
        elif row['LOS'] == 1 and row['label'] == 2:
            color = 'green'  # Changed from lightgreen
            size = 3
        elif row['LOS'] == 1 and row['label'] == 3:
            color = 'magenta'
            size = 3
        else:
            color = 'grey'
            size = 2

        # For plotting, swap coordinates: x-axis shows y-distance, y-axis shows x-distance.
        scatter_x.append(row['y'])
        scatter_y.append(row['x'])
        colors.append(color)
        sizes.append(size)
        
        # Format hover text for the object:
        # id, mirrProb, dp, poe as int; vx, vy as float (2 decimals); pfd as float (4 decimals)
        if row['Motion'] == 1:
            hover_text = (f"id: {int(row['id'])}, mirrProb: {int(row['mirrProb'])}, dp: {int(row['dp'])}, "
                          f"poe: {int(row['poe'])}, vx: {row['vx']:.2f}, vy: {row['vy']:.2f}, pfd: {row['pfd']:.4f}")
        else:
            hover_text = ""
        hovers.append(hover_text)
        
        # Compute rectangular bounds from object's local corner data.
        lf = row['lf'] * 0.001
        lr = row['lr'] * 0.001
        wl = row['wl'] * 0.001
        wr = row['wr'] * 0.001
        # Define local corners: front-left, front-right, rear-right, rear-left.
        local_corners = np.array([[lf, wl],
                                  [lf, -wr],
                                  [-lr, -wr],
                                  [-lr, wl]])
        # Compute rotation matrix and transform to ego coordinate system.
        theta = row['orient']
        cos_t = math.cos(theta)
        sin_t = math.sin(theta)
        R = np.array([[cos_t, -sin_t],
                      [sin_t,  cos_t]])
        global_corners = (R @ local_corners.T).T + np.array([row['x'], row['y']])
        # Swap coordinates for plotting (x = global y, y = global x).
        xs = global_corners[:, 1].tolist()
        ys = global_corners[:, 0].tolist()
        # Explicitly close the polygon by appending the first point.
        xs.append(xs[0])
        ys.append(ys[0])
        patch_xs.append(xs)
        patch_ys.append(ys)
        patch_colors.append(color)
        
    object_scatter_source.data = dict(x=scatter_x, y=scatter_y, color=colors, size=sizes, hover=hovers)
    object_patch_source.data = dict(xs=patch_xs, ys=patch_ys, color=patch_colors)
    
    # Update ego point: use the first object from the filtered set.
    ego_info = df_cycle.iloc[0]
    # Convert egoYawRate from rad/s to deg/s and format values.
    ego_hover_text = (f"mc: {int(ego_info['mc'])}, "
                      f"egoSpeed: {ego_info['egoSpeed']:.3f}, "
                      f"egoYawRate: {math.degrees(ego_info['egoYawRate']):.3f} deg/s")
    ego_source.data = dict(x=[0], y=[0], hover=[ego_hover_text])

def update_time_series(source, label_val, title_prefix):
    """Update the POE vs. mc plot for an object with a given label and OOI==1."""
    current_mc = radar_cycle_slider.value
    df_cycle = df[df.mc == current_mc].to_pandas_df()
    obj_data = df_cycle[(df_cycle.OOI == 1) & (df_cycle.label == label_val)]
    if not obj_data.empty:
        obj_id = obj_data.iloc[0]['id']
        current_poe = obj_data.iloc[0]['poe']
        df_obj = df[df.id == obj_id].to_pandas_df()
        df_obj = df_obj[(df_obj.mc >= current_mc - 5) & (df_obj.mc <= current_mc + 5)]
        df_obj = df_obj.sort_values('mc')
        source.data = dict(mc=df_obj['mc'].tolist(), poe=df_obj['poe'].tolist())
        return f"<b>{title_prefix} OOId: {obj_id} | POE: {current_poe}</b>"
    else:
        source.data = dict(mc=[], poe=[])
        return f"<b>{title_prefix} No Data</b>"

def update_all(event=None):
    update_object_plot()
    title_ego = update_time_series(ts_source_ego, 1, "inEgoLaneOOI")
    title_left = update_time_series(ts_source_left, 2, "inLeftEgoLaneOOI")
    title_right = update_time_series(ts_source_right, 3, "inRightEgoLaneOOI")
    ts_plot_ego.title.text = title_ego
    ts_plot_left.title.text = title_left
    ts_plot_right.title.text = title_right

# Attach callbacks to all relevant sliders.
for widget in [radar_cycle_slider, x_axis_slider, y_axis_slider, eyr_slider, es_slider, mp_slider, age_slider]:
    widget.param.watch(update_all, 'value')

def save_callback(event):
    pn.panel(dashboard_layout).save('dashboard_state.html', resources='inline')
    print(f"[{time.time()-dashboard_start:.3f} sec] Dashboard state saved to dashboard_state.html")
save_button.on_click(save_callback)

# ---------------------------
# LAYOUT CONSTRUCTION
# ---------------------------
header_section = pn.pane.Markdown(
    "<h1 style='font-family: Courier New, monospace; text-align: center;'>Objects Of Interest (OOI)</h1>",
    sizing_mode="stretch_width", height=50
)

slider_section = pn.Row(y_axis_slider, x_axis_slider, radar_cycle_slider, sizing_mode="stretch_width", height=50)

# Arrange grid: 2 rows x 3 columns; grid max_height set to 1000.
grid = pn.GridSpec(sizing_mode='stretch_both', max_height=1000)
grid[0, 0] = pn.Column(eyr_slider, es_slider, mp_slider, age_slider)  # Subsection 1: filter sliders
grid[0, 1] = ts_plot_ego                                             # Subsection 2: POE time series (ego lane)
grid[0, 2] = empty_plot                                              # Subsection 3: empty
grid[1, 0] = ts_plot_left                                              # Subsection 4: POE time series (left lane)
grid[1, 1] = object_plot                                               # Subsection 5: main object plot
grid[1, 2] = ts_plot_right                                             # Subsection 6: POE time series (right lane)

dashboard_layout = pn.Column(header_section, slider_section, grid, save_button,
                               sizing_mode="stretch_both", margin=0)

# Ensure initial update with actual data from the first radar cycle.
update_all()

dashboard_layout.servable()
print(f"[{time.time()-dashboard_start:.3f} sec] Dashboard creation complete.")

# ---------------------------
# LAUNCH THE DASHBOARD
# ---------------------------
pn.serve(dashboard_layout, show=True, start=True)
