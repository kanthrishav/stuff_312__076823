import os
import time
import math
import numpy as np
import pandas as pd
import vaex
import panel as pn
from bokeh.plotting import figure
from bokeh.models import ColumnDataSource, HoverTool, Span, Label
from bokeh.io import curdoc
from numba import njit, prange

# ---------------------------
# INITIALIZE PANEL & SET GLOBAL CSS
# ---------------------------
pn.extension()
pn.config.raw_css.append("""
    .bk-root { font-family: "Courier New", monospace; }
    body { margin: 0; padding: 0; background-color: #CBCB24; }
    .slider-section { color: #40400B; }
""")
print(f"[{time.time():.3f}] Panel extension loaded.")

# ---------------------------
# PARAMETERS & FILE PATHS
# ---------------------------
LOS_thresh = 0.035
original_file_path = "data_original.feather"
preprocessed_file_path = "data_preprocessed.feather"

# ---------------------------
# DATA PREPROCESSING
# ---------------------------
start_total = time.time()
preprocess_start = time.time()

if os.path.exists(preprocessed_file_path):
    pdf = pd.read_feather(preprocessed_file_path)
else:
    pdf = pd.read_feather(original_file_path)
    pdf['az'] = np.arctan2(pdf['y'].values, pdf['x'].values)
    pdf['r'] = np.hypot(pdf['x'].values, pdf['y'].values)
    pdf['Motion'] = np.where(pdf['dp'].isin([1,2,5,6]), 1, 0)
    print(f"[{time.time()-preprocess_start:.3f} sec] Basic columns computed.")
    
    @njit(parallel=True)
    def compute_all_los(sorted_az, sorted_r, group_start, group_end, thresh):
        n_groups = group_start.shape[0]
        los_sorted = np.empty(sorted_az.shape[0], dtype=np.int8)
        for i in prange(n_groups):
            start = group_start[i]
            end = group_end[i]
            for j in range(start, end):
                flag = 1
                for k in range(start, end):
                    if j != k:
                        if sorted_r[k] < sorted_r[j] and math.fabs(sorted_az[k]-sorted_az[j]) < thresh:
                            flag = 0
                            break
                los_sorted[j] = flag
        return los_sorted
    
    mc_arr = pdf['mc'].values
    order = np.argsort(mc_arr)
    sorted_mc = mc_arr[order]
    sorted_az = pdf['az'].values[order]
    sorted_r = pdf['r'].values[order]
    unique_mc, group_start = np.unique(sorted_mc, return_index=True)
    group_end = np.empty_like(group_start)
    for i in range(len(group_start)-1):
        group_end[i] = group_start[i+1]
    group_end[-1] = len(sorted_mc)
    los_sorted = compute_all_los(sorted_az, sorted_r, group_start, group_end, LOS_thresh)
    los = np.empty_like(los_sorted)
    los[order] = los_sorted
    pdf['LOS'] = los
    print(f"[{time.time()-preprocess_start:.3f} sec] LOS column computed.")
    
    mirrProb = pdf['mirrProb'].values
    egoYawRate = pdf['egoYawRate'].values
    egoSpeed = pdf['egoSpeed'].values
    Motion = pdf['Motion'].values
    LOS = pdf['LOS'].values
    egoYawRate_deg = np.degrees(egoYawRate)
    y_vals = pdf['y'].values
    cond = (mirrProb < 71) & (np.abs(egoYawRate_deg) < 2) & (egoSpeed > 0.2) & (Motion == 1) & (LOS == 1)
    labels = np.zeros(len(pdf), dtype=np.int8)
    labels[np.where(cond & (y_vals >= -2) & (y_vals <= 2))] = 1
    labels[np.where(cond & (y_vals >= -6) & (y_vals < -2))] = 2
    labels[np.where(cond & (y_vals > 2) & (y_vals <= 6))] = 3
    pdf['label'] = labels
    print(f"[{time.time()-preprocess_start:.3f} sec] Label column computed.")
    
    labels_arr = pdf['label'].values
    mc_arr = pdf['mc'].values
    r_arr = pdf['r'].values
    mask = (labels_arr == 1) | (labels_arr == 2) | (labels_arr == 3)
    sel = np.where(mask)[0]
    pdf['OOI'] = 0
    if sel.size > 0:
        order_sel = np.argsort(r_arr[sel])
        ordered_sel = sel[order_sel]
        keys = np.stack((mc_arr[ordered_sel], labels_arr[ordered_sel]), axis=1)
        unique_keys, unique_idx = np.unique(keys, axis=0, return_index=True)
        selected_indices = ordered_sel[unique_idx]
        pdf.loc[selected_indices, 'OOI'] = 1
    print(f"[{time.time()-preprocess_start:.3f} sec] OOI column computed.")
    
    pdf.to_feather(preprocessed_file_path)
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed dataframe saved.")

print(f"[{time.time()-preprocess_start:.3f} sec] Data preprocessing complete.")
print(f"[{time.time()-start_total:.3f} sec] Total initialization complete.")

# Convert to Vaex dataframe for on-demand filtering
df = vaex.from_pandas(pdf)

# ---------------------------
# DASHBOARD CREATION
# ---------------------------
dashboard_start = time.time()

# Create Radar Cycle Slider from actual unique mc values
unique_mcs = sorted(list(set(pdf['mc'].astype(int).tolist())))
radar_cycle_slider = pn.widgets.DiscreteSlider(name='Radar Cycle Slider',
                                                options=unique_mcs,
                                                value=unique_mcs[0],
                                                width=1400)

cycle_input = pn.widgets.TextInput(name="Cycle Input", value="", width=100)
cycle_go_button = pn.widgets.Button(name="Go", button_type="primary")
def go_to_cycle(event):
    try:
        val = int(cycle_input.value)
        if val in unique_mcs:
            radar_cycle_slider.value = val
        else:
            print(f"Cycle {val} not found in data.")
    except Exception as e:
        print("Invalid cycle input:", e)
cycle_go_button.on_click(go_to_cycle)

# Filter Panel
eyr_slider = pn.widgets.FloatSlider(name='EYR Slider', start=0, end=5, value=2, step=0.01)
es_slider = pn.widgets.FloatSlider(name='ES Slider', start=0, end=10, value=0.2, step=0.1)
mp_slider = pn.widgets.FloatSlider(name='MP Slider', start=0, end=100, value=71, step=1)
age_slider = pn.widgets.FloatSlider(name='Age Slider', start=0, end=100, value=0, step=1)
x_axis_slider = pn.widgets.FloatSlider(name='X-axis Slider', start=1, end=30, value=10, step=1)
y_axis_slider = pn.widgets.FloatSlider(name='Y-axis Slider', start=-200, end=200, value=100, step=1)
min_az_input = pn.widgets.TextInput(name="Min Az (deg)", value="-180", width=50)
max_az_input = pn.widgets.TextInput(name="Max Az (deg)", value="180", width=50)
stats_pane = pn.pane.Markdown("", sizing_mode="stretch_width")
filter_panel = pn.Column(eyr_slider, es_slider, mp_slider, age_slider, x_axis_slider, y_axis_slider,
                           pn.Row(min_az_input, max_az_input), stats_pane, sizing_mode="stretch_width")

# Navigation Controls
prev_button = pn.widgets.Button(name="<", button_type="primary", width=30)
step_button = pn.widgets.Button(name=">", button_type="primary", width=30)
run_button = pn.widgets.Button(name="Run", button_type="success", width=40)
step_size_input = pn.widgets.TextInput(name="Step Size (s)", value="2", width=50)
stop_button = pn.widgets.Button(name="", button_type="danger", width=40, height=run_button.height)
animate_callback = None
def step_callback(event):
    current_value = radar_cycle_slider.value
    idx = unique_mcs.index(current_value)
    if idx < len(unique_mcs) - 1:
        radar_cycle_slider.value = unique_mcs[idx + 1]
    else:
        radar_cycle_slider.value = unique_mcs[0]
def prev_callback(event):
    current_value = radar_cycle_slider.value
    idx = unique_mcs.index(current_value)
    if idx > 0:
        radar_cycle_slider.value = unique_mcs[idx - 1]
    else:
        radar_cycle_slider.value = unique_mcs[-1]
prev_button.on_click(prev_callback)
step_button.on_click(step_callback)
def animate_func():
    step_callback(None)
def run_click(event):
    global animate_callback
    try:
        val = float(step_size_input.value)
    except:
        val = 2.0
    period = int(1000 / val)
    animate_callback = curdoc().add_periodic_callback(animate_func, period)
run_button.on_click(run_click)
def stop_click(event):
    global animate_callback
    if animate_callback is not None:
        try:
            curdoc().remove_periodic_callback(animate_callback)
        except Exception as e:
            print("Error stopping animation:", e)
        animate_callback = None
stop_button.on_click(stop_click)

radar_control_row = pn.Row(radar_cycle_slider, cycle_input, cycle_go_button, prev_button, step_button,
                           run_button, step_size_input, stop_button, sizing_mode="stretch_width")

# Add small vertical spacers between some controls and plots in main tab:
cycle_input_spacer = pn.Spacer(height=10)
step_size_spacer = pn.Spacer(height=10)

save_button = pn.widgets.Button(name='Save Current State', button_type="primary")

# ---------------------------
# Histogram Tab Controls
# ---------------------------
hist_motion = pn.widgets.TextInput(name="Motion", value="1", width=50)
hist_ooi = pn.widgets.TextInput(name="OOI", value="1", width=50)
hist_los = pn.widgets.TextInput(name="LOS", value="1", width=50)
binLow_input = pn.widgets.TextInput(name="binLow", value="0", width=50)
binHigh_input = pn.widgets.TextInput(name="binHigh", value="100", width=50)
hist_mp = pn.widgets.FloatSlider(name="MP", start=0, end=100, value=71, step=1)
hist_age = pn.widgets.FloatSlider(name="Age", start=1, end=500, value=20, step=1)
hist_controls = pn.Row(hist_motion, hist_ooi, hist_los, hist_mp, hist_age, binLow_input, binHigh_input, sizing_mode="stretch_width")

# ---------------------------
# Histogram Section
# ---------------------------
def create_histogram_fig(title):
    p = figure(title=title, sizing_mode="stretch_both", tools="pan,wheel_zoom,reset", height=480,
               background_fill_color="#545E5D", outline_line_color="#49490D", outline_line_width=4)
    p.x_range.start = -5
    p.x_range.end = 105
    p.y_range.start = -5
    p.y_range.end = 105
    return p

left_hist = create_histogram_fig("LeftEgoHist")
in_hist = create_histogram_fig("InEgoHist")
right_hist = create_histogram_fig("RightEgoHist")

left_hist_source = ColumnDataSource(data=dict(top=[], left=[], right=[]))
in_hist_source = ColumnDataSource(data=dict(top=[], left=[], right=[]))
right_hist_source = ColumnDataSource(data=dict(top=[], left=[], right=[]))

left_hist.quad(top='top', bottom=0, left='left', right='right', source=left_hist_source,
               fill_color="#CE3C2E", line_color="#CE3C2E")
in_hist.quad(top='top', bottom=0, left='left', right='right', source=in_hist_source,
             fill_color="#CE3C2E", line_color="#CE3C2E")
right_hist.quad(top='top', bottom=0, left='left', right='right', source=right_hist_source,
                fill_color="#CE3C2E", line_color="#CE3C2E")

left_hist_stats = pn.pane.Markdown("", sizing_mode="stretch_width")
in_hist_stats = pn.pane.Markdown("", sizing_mode="stretch_width")
right_hist_stats = pn.pane.Markdown("", sizing_mode="stretch_width")

def update_histograms_all():
    df_all = pdf
    try:
        motion_val = int(hist_motion.value)
    except:
        motion_val = None
    try:
        ooi_val = int(hist_ooi.value)
    except:
        ooi_val = None
    try:
        los_val = int(hist_los.value)
    except:
        los_val = None
    if motion_val is not None:
        df_all = df_all[df_all['Motion'] == motion_val]
    if ooi_val is not None:
        df_all = df_all[df_all['OOI'] == ooi_val]
    if los_val is not None:
        df_all = df_all[df_all['LOS'] == los_val]
    df_all = df_all[df_all['mirrProb'] < hist_mp.value]
    df_all = df_all[df_all['lc'] > hist_age.value]
    try:
        binLow = float(binLow_input.value)
    except:
        binLow = 0
    try:
        binHigh = float(binHigh_input.value)
    except:
        binHigh = 100
    def compute_histogram(label_val):
        subset = df_all[df_all['OOI'] == 1]
        subset = subset[subset['label'] == label_val]
        if subset.empty:
            return np.array([]), np.array([])
        poe_vals = subset['poe'].values
        counts, bins = np.histogram(poe_vals, bins=100, range=(binLow, binHigh))
        total = counts.sum()
        if total > 0:
            pct = (counts/total)*100
        else:
            pct = counts
        return pct, bins
    left_pct, left_bins = compute_histogram(2)
    in_pct, in_bins = compute_histogram(1)
    right_pct, right_bins = compute_histogram(3)
    def update_hist_source(source, pct, bins):
        if pct.size == 0:
            source.data = dict(top=[], left=[], right=[])
        else:
            lefts = bins[:-1]
            rights = bins[1:]
            source.data = dict(top=pct.tolist(), left=lefts.tolist(), right=rights.tolist())
    update_hist_source(left_hist_source, left_pct, left_bins)
    update_hist_source(in_hist_source, in_pct, in_bins)
    update_hist_source(right_hist_source, right_pct, right_bins)
    def compute_stats(poe_array):
        total = poe_array.size
        if total == 0:
            return "No data"
        pct_ge_99 = np.sum(poe_array >= 99)/total*100
        pct_ge_98 = np.sum((poe_array >= 98) & (poe_array < 99))/total*100
        pct_ge_70 = np.sum((poe_array >= 70) & (poe_array < 98))/total*100
        pct_lt_50 = np.sum(poe_array < 50)/total*100
        return (f"Total: {total}<br>"
                f"% >= 99: {pct_ge_99:.4f}<br>"
                f"% >= 98 and < 99: {pct_ge_98:.4f}<br>"
                f"% >= 70 and < 98: {pct_ge_70:.4f}<br>"
                f"% < 50: {pct_lt_50:.4f}")
    left_stats = compute_stats(df_all[(df_all['OOI'] == 1) & (df_all['label'] == 2)]['poe'].values)
    in_stats = compute_stats(df_all[(df_all['OOI'] == 1) & (df_all['label'] == 1)]['poe'].values)
    right_stats = compute_stats(df_all[(df_all['OOI'] == 1) & (df_all['label'] == 3)]['poe'].values)
    left_hist_stats.object = left_stats
    in_hist_stats.object = in_stats
    right_hist_stats.object = right_stats

def update_all(event=None):
    update_object_plot()
    update_histograms_all()
    title_ego = update_time_series(ts_source_ego, 1, "inEgoLaneOOI")
    title_left = update_time_series(ts_source_left, 2, "inLeftEgoLaneOOI")
    title_right = update_time_series(ts_source_right, 3, "inRightEgoLaneOOI")
    ts_plot_ego.title.text = title_ego
    ts_plot_left.title.text = title_left
    ts_plot_right.title.text = title_right

for widget in [radar_cycle_slider, x_axis_slider, y_axis_slider, eyr_slider, es_slider, mp_slider, age_slider,
               min_az_input, max_az_input]:
    widget.param.watch(update_all, 'value')

def save_callback(event):
    global animate_callback
    if animate_callback is not None:
        try:
            curdoc().remove_periodic_callback(animate_callback)
        except Exception as e:
            print("Error stopping animation:", e)
        animate_callback = None
    update_all()
    pn.panel(dashboard_layout).save('dashboard_state.html', resources='inline')
    print(f"[{time.time()-dashboard_start:.3f} sec] Dashboard state saved.")

save_button.on_click(save_callback)

# ---------------------------
# LAYOUT CONSTRUCTION
# ---------------------------
header_section = pn.pane.Markdown(
    "<h1 style='font-family: Courier New, monospace; text-align: center;'>Objects of Interest (OOI)</h1>",
    sizing_mode="stretch_width", height=50
)

radar_control_row = pn.Row(radar_cycle_slider, cycle_input, cycle_go_button, prev_button, step_button,
                           run_button, step_size_input, stop_button, sizing_mode="stretch_width")
# Add small vertical spacers for margins
spacer1 = pn.Spacer(height=10)
spacer2 = pn.Spacer(height=10)

slider_section = pn.Column(radar_control_row, spacer1, sizing_mode="stretch_width", height=70)

grid = pn.GridSpec(sizing_mode='stretch_both', max_height=1000)
grid[0, 0] = filter_panel
grid[1, 0] = ts_plot_left
grid[0:2, 1] = birdseye_plot
grid[0, 2] = ts_plot_ego
grid[1, 2] = ts_plot_right

main_dashboard = pn.Column(header_section, slider_section, grid, save_button, sizing_mode="stretch_both", margin=0)

# Histogram section on its own tab
hist_row = pn.Row(
    pn.Column(left_hist, left_hist_stats, sizing_mode="stretch_both"),
    pn.Column(in_hist, in_hist_stats, sizing_mode="stretch_both"),
    pn.Column(right_hist, right_hist_stats, sizing_mode="stretch_both"),
    sizing_mode="stretch_width", height=480
)
# Place histogram control row (all 5 text boxes and 2 sliders) in one row
hist_controls = pn.Row(hist_motion, hist_ooi, hist_los, hist_mp, hist_age, binLow_input, binHigh_input, sizing_mode="stretch_width")
hist_section = pn.Column(pn.pane.Markdown("<h2 style='color:white;'>Histogram</h2>", sizing_mode="stretch_width"),
                         hist_row, hist_controls, sizing_mode="stretch_width")

tabs = pn.Tabs(
    ("main", main_dashboard),
    ("hist", hist_section)
)

update_all()
pn.state.onload(lambda: update_all())

tabs.servable()
print(f"[{time.time()-dashboard_start:.3f} sec] Dashboard creation complete.")

pn.serve(tabs, show=True, start=True)
