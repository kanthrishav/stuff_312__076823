import os
import time
import math
import numpy as np
import pandas as pd
import vaex
import panel as pn
from bokeh.plotting import figure
from bokeh.models import ColumnDataSource, HoverTool
from numba import njit, prange

# ---------------------------
# INITIALIZE PANEL (fix extension warning)
# ---------------------------
pn.extension()  # Do not specify "bokeh" explicitly to avoid the extension warning
pn.config.raw_css.append("""
    .bk-root { font-family: "Courier New", monospace; }
    body { margin: 0; padding: 0; }
""")
print(f"[{time.time():.3f}] Panel extension loaded.")

# ---------------------------
# PARAMETERS & FILE PATHS
# ---------------------------
LOS_thresh = 0.1  # radians for LOS computation
original_file_path = "data_original.feather"
preprocessed_file_path = "data_preprocessed.feather"

# ---------------------------
# DATA PREPROCESSING (with timing prints)
# ---------------------------
start_total = time.time()
preprocess_start = time.time()

if os.path.exists(preprocessed_file_path):
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed file found. Loading preprocessed dataframe.")
    pdf = pd.read_feather(preprocessed_file_path)
else:
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed file not found. Reading original data and starting preprocessing.")
    pdf = pd.read_feather(original_file_path)
    
    # --- Compute basic geometric quantities (vectorized) ---
    pdf['az'] = np.arctan2(pdf['y'].values, pdf['x'].values)  # azimuth angle (radians)
    pdf['r'] = np.hypot(pdf['x'].values, pdf['y'].values)       # range (distance)
    pdf['Motion'] = np.where(pdf['dp'].isin([1, 2, 5, 6]), 1, 0)
    print(f"[{time.time()-preprocess_start:.3f} sec] Basic columns (az, r, Motion) computed.")

    # --- LOS Computation (fully parallelized with Numba) ---
    @njit(parallel=True)
    def compute_all_los(sorted_az, sorted_r, group_start, group_end, thresh):
        n_groups = group_start.shape[0]
        los_sorted = np.empty(sorted_az.shape[0], dtype=np.int8)
        for i in prange(n_groups):
            start = group_start[i]
            end = group_end[i]
            for j in range(start, end):
                flag = 1
                for k in range(start, end):
                    if j != k:
                        if sorted_r[k] < sorted_r[j] and math.fabs(sorted_az[k] - sorted_az[j]) < thresh:
                            flag = 0
                            break
                los_sorted[j] = flag
        return los_sorted

    # Sort indices by radar cycle for efficient group processing
    mc_arr = pdf['mc'].values
    order = np.argsort(mc_arr)
    sorted_mc = mc_arr[order]
    sorted_az = pdf['az'].values[order]
    sorted_r = pdf['r'].values[order]
    unique_mc, group_start = np.unique(sorted_mc, return_index=True)
    group_end = np.empty_like(group_start)
    for i in range(len(group_start)-1):
        group_end[i] = group_start[i+1]
    group_end[-1] = len(sorted_mc)
    
    # Compute LOS for all objects in sorted order, then reassemble
    los_sorted = compute_all_los(sorted_az, sorted_r, group_start, group_end, LOS_thresh)
    los = np.empty_like(los_sorted)
    los[order] = los_sorted
    pdf['LOS'] = los
    print(f"[{time.time()-preprocess_start:.3f} sec] LOS column computed.")

    # --- Label Computation (vectorized) ---
    mirrProb = pdf['mirrProb'].values
    egoYawRate = pdf['egoYawRate'].values
    egoSpeed = pdf['egoSpeed'].values
    Motion = pdf['Motion'].values
    LOS = pdf['LOS'].values
    y_vals = pdf['y'].values
    cond = (mirrProb < 71) & (egoYawRate < 2) & (egoSpeed > 0.2) & (Motion == 1) & (LOS == 1)
    labels = np.zeros(len(pdf), dtype=np.int8)
    labels[np.where(cond & (y_vals >= -2) & (y_vals <= 2))] = 1
    labels[np.where(cond & (y_vals >= -6) & (y_vals < -2))] = 2
    labels[np.where(cond & (y_vals > 2) & (y_vals <= 6))] = 3
    pdf['label'] = labels
    print(f"[{time.time()-preprocess_start:.3f} sec] Label column computed.")

    # --- OOI Computation (fully vectorized using NumPy) ---
    labels_arr = pdf['label'].values
    mc_arr = pdf['mc'].values
    r_arr = pdf['r'].values
    mask = (labels_arr == 1) | (labels_arr == 2) | (labels_arr == 3)
    sel = np.where(mask)[0]
    pdf['OOI'] = 0  # initialize all to 0
    if sel.size > 0:
        sel_mc = mc_arr[sel]
        sel_label = labels_arr[sel]
        sel_r = r_arr[sel]
        order_sel = np.argsort(sel_r)
        ordered_sel = sel[order_sel]
        # Create keys from (mc, label)
        keys = np.stack((mc_arr[ordered_sel], labels_arr[ordered_sel]), axis=1)
        # Find unique (mc, label) pairs; the first occurrence (lowest r) is chosen
        unique_keys, unique_idx = np.unique(keys, axis=0, return_index=True)
        selected_indices = ordered_sel[unique_idx]
        pdf.loc[selected_indices, 'OOI'] = 1
    print(f"[{time.time()-preprocess_start:.3f} sec] OOI column computed.")

    # --- Save the preprocessed dataframe ---
    pdf.to_feather(preprocessed_file_path)
    print(f"[{time.time()-preprocess_start:.3f} sec] Preprocessed dataframe saved to {preprocessed_file_path}.")

print(f"[{time.time()-preprocess_start:.3f} sec] Data preprocessing complete.")
print(f"[{time.time()-start_total:.3f} sec] Total initialization complete.")

# Convert to Vaex dataframe (for on-demand filtering)
df = vaex.from_pandas(pdf)

# ---------------------------
# DASHBOARD CREATION
# ---------------------------
dashboard_start = time.time()

# --- Create main slider widgets (in a horizontal row) ---
y_axis_slider = pn.widgets.FloatSlider(name='Y-axis Slider', start=-200, end=200, value=100, step=1)
x_axis_slider = pn.widgets.FloatSlider(name='X-axis Slider', start=1, end=30, value=10, step=1)
radar_cycle_slider = pn.widgets.IntSlider(name='Radar Cycle Slider', 
                                           start=int(df.mc.min()), end=int(df.mc.max()),
                                           value=int(df.mc.min()), step=1)

# --- Create filter sliders (stacked vertically in Graph Subsection 1) ---
eyr_slider = pn.widgets.FloatSlider(name='EYR Slider', start=0, end=5, value=2, step=0.01)
es_slider = pn.widgets.FloatSlider(name='ES Slider', start=0, end=10, value=0.2, step=0.1)
mp_slider = pn.widgets.FloatSlider(name='MP Slider', start=0, end=100, value=71, step=1)
age_slider = pn.widgets.FloatSlider(name='Age Slider', start=0, end=100, value=20, step=1)

# --- Save button to export dashboard state as interactive HTML ---
save_button = pn.widgets.Button(name='Save Current State', button_type='primary')

# ---------------------------
# Prepare ColumnDataSources for fast updates
# ---------------------------
object_scatter_source = ColumnDataSource(data=dict(x=[], y=[], color=[], size=[], hover=[]))
object_patch_source = ColumnDataSource(data=dict(xs=[], ys=[], color=[]))
ego_source = ColumnDataSource(data=dict(x=[0], y=[0], hover=["mc: NA, egoSpeed: NA, egoYawRate: NA"]))

ts_source_ego = ColumnDataSource(data=dict(mc=[], poe=[]))
ts_source_left = ColumnDataSource(data=dict(mc=[], poe=[]))
ts_source_right = ColumnDataSource(data=dict(mc=[], poe=[]))

# ---------------------------
# Create Bokeh Figures
# ---------------------------
object_plot = figure(title="Object Plot", sizing_mode="stretch_both", tools="pan,wheel_zoom,reset")
scatter_renderer = object_plot.scatter('x', 'y', source=object_scatter_source,
                                         size='size', color='color', fill_alpha=0.6)
object_plot.patches('xs', 'ys', source=object_patch_source, fill_alpha=0.1, line_color='color')
object_plot.scatter('x', 'y', source=ego_source, size=3, color='black', fill_alpha=1.0)
object_plot.add_tools(HoverTool(tooltips=[("Details", "@hover")], renderers=[scatter_renderer]))

ts_plot_ego = figure(title="inEgoLaneOOI", sizing_mode="stretch_both", tools="pan,wheel_zoom,reset", y_range=(0, 100))
ts_plot_left = figure(title="inLeftEgoLaneOOI", sizing_mode="stretch_both", tools="pan,wheel_zoom,reset", y_range=(0, 100))
ts_plot_right = figure(title="inRightEgoLaneOOI", sizing_mode="stretch_both", tools="pan,wheel_zoom,reset", y_range=(0, 100))
for p in [ts_plot_ego, ts_plot_left, ts_plot_right]:
    p.scatter([], [])

empty_plot = figure(sizing_mode="stretch_both", toolbar_location=None)
empty_plot.scatter([], [])

# ---------------------------
# Callback Functions for Fast Updates
# ---------------------------
def update_object_plot():
    """Update the main object plot (scatter and patches) instantly using ColumnDataSource."""
    current_mc = radar_cycle_slider.value
    x_lim = x_axis_slider.value
    y_lim = y_axis_slider.value
    
    object_plot.x_range.start = -x_lim
    object_plot.x_range.end = x_lim
    object_plot.y_range.start = 0
    object_plot.y_range.end = y_lim

    # Filter data for the current radar cycle and apply filter sliders
    df_cycle = df[df.mc == current_mc].to_pandas_df()
    # Apply additional filters
    df_cycle = df_cycle[(df_cycle.egoYawRate < eyr_slider.value) &
                        (df_cycle.egoSpeed > es_slider.value) &
                        (df_cycle.mirrProb < mp_slider.value) &
                        (df_cycle.lc > age_slider.value)]
    
    # If after filtering no objects remain, reset sources and set ego defaults
    if df_cycle.empty:
        object_scatter_source.data = dict(x=[], y=[], color=[], size=[], hover=[])
        object_patch_source.data = dict(xs=[], ys=[], color=[])
        ego_source.data = dict(x=[0], y=[0], hover=["mc: NA, egoSpeed: NA, egoYawRate: NA"])
        return

    scatter_x, scatter_y, colors, sizes, hovers = [], [], [], [], []
    patch_xs, patch_ys, patch_colors = [], [], []

    for _, row in df_cycle.iterrows():
        if row['OOI'] == 1:
            color = 'red'
            size = 4
        elif row['LOS'] == 1 and row['label'] == 1:
            color = 'lightblue'
            size = 3
        elif row['LOS'] == 1 and row['label'] == 2:
            color = 'lightgreen'
            size = 3
        elif row['LOS'] == 1 and row['label'] == 3:
            color = 'magenta'
            size = 3
        else:
            color = 'grey'
            size = 2

        # Note: x-axis displays y distance; y-axis displays x distance
        scatter_x.append(row['y'])
        scatter_y.append(row['x'])
        colors.append(color)
        sizes.append(size)
        
        # Hover text (only for objects with Motion==1)
        if row['Motion'] == 1:
            hover_text = (f"id: {row['id']}, lc: {row['lc']}, mirrProb: {row['mirrProb']}, "
                          f"vx: {row['vx']}, vy: {row['vy']}, dp: {row['dp']}, "
                          f"poe: {row['poe']}, pfd: {row['pfd']}")
        else:
            hover_text = ""
        hovers.append(hover_text)
        
        # Compute rectangular bounds from object's position, orientation and corner coordinates
        lf = row['lf'] * 0.001
        lr = row['lr'] * 0.001
        wl = row['wl'] * 0.001
        wr = row['wr'] * 0.001
        local_corners = np.array([[lf, wl],
                                  [lf, -wr],
                                  [-lr, -wr],
                                  [-lr, wl]])
        theta = row['orient']
        cos_t = math.cos(theta)
        sin_t = math.sin(theta)
        R = np.array([[cos_t, -sin_t],
                      [sin_t,  cos_t]])
        global_corners = (R @ local_corners.T).T + np.array([row['x'], row['y']])
        # Swap coordinates for plotting
        patch_xs.append(global_corners[:, 1].tolist())
        patch_ys.append(global_corners[:, 0].tolist())
        patch_colors.append(color)
        
    object_scatter_source.data = dict(x=scatter_x, y=scatter_y, color=colors, size=sizes, hover=hovers)
    object_patch_source.data = dict(xs=patch_xs, ys=patch_ys, color=patch_colors)
    
    # Update ego source safely (if df_cycle is not empty)
    ego_info = df_cycle.iloc[0]
    ego_hover = f"mc: {ego_info['mc']}, egoSpeed: {ego_info['egoSpeed']}, egoYawRate: {ego_info['egoYawRate']}"
    ego_source.data = dict(x=[0], y=[0], hover=[ego_hover])

def update_time_series(source, label_val, title_prefix):
    """Update the POE vs. mc plot for an object with a given label and OOI==1."""
    current_mc = radar_cycle_slider.value
    df_cycle = df[df.mc == current_mc].to_pandas_df()
    obj_data = df_cycle[(df_cycle.OOI == 1) & (df_cycle.label == label_val)]
    if not obj_data.empty:
        obj_id = obj_data.iloc[0]['id']
        current_poe = obj_data.iloc[0]['poe']
        df_obj = df[df.id == obj_id].to_pandas_df()
        df_obj = df_obj[(df_obj.mc >= current_mc - 5) & (df_obj.mc <= current_mc + 5)]
        df_obj = df_obj.sort_values('mc')
        source.data = dict(mc=df_obj['mc'].tolist(), poe=df_obj['poe'].tolist())
        return f"<b>{title_prefix} OOId: {obj_id} | POE: {current_poe}</b>"
    else:
        source.data = dict(mc=[], poe=[])
        return f"<b>{title_prefix} No Data</b>"

def update_all(event=None):
    update_object_plot()
    title_ego = update_time_series(ts_source_ego, 1, "inEgoLaneOOI")
    title_left = update_time_series(ts_source_left, 2, "inLeftEgoLaneOOI")
    title_right = update_time_series(ts_source_right, 3, "inRightEgoLaneOOI")
    ts_plot_ego.title.text = title_ego
    ts_plot_left.title.text = title_left
    ts_plot_right.title.text = title_right

for widget in [radar_cycle_slider, x_axis_slider, y_axis_slider, eyr_slider, es_slider, mp_slider, age_slider]:
    widget.param.watch(update_all, 'value')

def save_callback(event):
    pn.panel(dashboard_layout).save('dashboard_state.html', resources='inline')
    print(f"[{time.time()-dashboard_start:.3f} sec] Dashboard state saved to dashboard_state.html")
save_button.on_click(save_callback)

# ---------------------------
# LAYOUT CONSTRUCTION
# ---------------------------
header_section = pn.pane.Markdown(
    "<h1 style='font-family: Courier New, monospace; text-align: center;'>Objects Of Interest (OOI)</h1>",
    sizing_mode="stretch_width", height=50
)

slider_section = pn.Row(y_axis_slider, x_axis_slider, radar_cycle_slider, sizing_mode="stretch_width", height=50)

grid = pn.GridSpec(sizing_mode='stretch_both', max_height=600)
grid[0, 0] = pn.Column(eyr_slider, es_slider, mp_slider, age_slider)  # Subsection 1: filter sliders
grid[0, 1] = ts_plot_ego                                             # Subsection 2: POE time series (ego lane)
grid[0, 2] = empty_plot                                              # Subsection 3: empty
grid[1, 0] = ts_plot_left                                              # Subsection 4: POE time series (left lane)
grid[1, 1] = object_plot                                               # Subsection 5: main object plot
grid[1, 2] = ts_plot_right                                             # Subsection 6: POE time series (right lane)

dashboard_layout = pn.Column(header_section, slider_section, grid, save_button,
                               sizing_mode="stretch_both", margin=0)

# Ensure an initial update so that plots appear instantly
update_all()

dashboard_layout.servable()
print(f"[{time.time()-dashboard_start:.3f} sec] Dashboard creation complete.")

# ---------------------------
# LAUNCH THE DASHBOARD
# ---------------------------
pn.serve(dashboard_layout, show=True, start=True)
